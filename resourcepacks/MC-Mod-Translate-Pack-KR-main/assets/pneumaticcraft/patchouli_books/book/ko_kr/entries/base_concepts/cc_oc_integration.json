{
  "name": "컴퓨터 호환",
  "icon": "pneumaticcraft:textures/patchouli/computer.png",
  "category": "pneumaticcraft:base_concepts",
  "flag": "|mod:computercraft,mod:opencomputers",
  "pages": [
    {
      "type": "text",
      "text": "$(thing)ComputerCraft/$ 또는 $(thing)Open Computers/$가 설치된 경우, 거의 모든 $(pncr) 기계 및 $(l:machines/drone_interface)드론/$과 상호작용할 수 있습니다.$(p)여기에 나열된 모든 기계는 CC/OC 주변기기로 상호작용할 수 있습니다."
    },
    {
      "type": "text",
      "title": "ComputerCraft",
      "text": "Lua에서 $(thing)m = peripheral.wrap(<side>)/$를 실행할 수 있습니다. 여기서 $(thing)<side>/$는 주변기기가 연결된 컴퓨터의 면(top, bottom, left, right, back, front)입니다. 그런 다음 $(thing)m.<functionName>/$으로 다음 함수들을 사용할 수 있습니다.$(p)다음 함수들 중 '<side>'가 인수로 나타나는 곳에서는 'up', 'down', 'north', 'south', 'east', 'west'가 유효합니다.",
      "flag": "mod:computercraft"
    },
    {
      "type": "text",
      "title": "Open Computers",
      "text": "컴퓨터를 $(pnc) 기계에 연결하려면 $(item)어댑터/$를 사용해야 합니다. 그러면 OC 구성 요소로 나타나며, OC Lua 환경에서 $(thing)=components.list()/$를 실행하면 확인할 수 있습니다. 그런 다음, 예를 들어 $(thing)p = components.air_compressor.getPressure()/$와 같이 사용하여 연결된 $(item)공기 압축기/$의 현재 압력을 가져오는 등 다음 함수들을 사용할 수 있습니다.",
      "flag": "mod:opencomputers"
    },
    {
      "type": "text",
      "title": "공통 메서드",
      "text": "다음 메서드들은 $(italic)모든/$ $(pncr) 기계에 공통적입니다:$(li)$(#800)getPressure(), getPressure(<side>)/$: 기계의 압력을 가져옵니다. <side>는 선택 사항이며, 측면별 압력이 다른 $(l:machines/vacuum_pump)진공 펌프/$에만 유용합니다.$(li)$(#800)getDangerPressure()/$: 기계가 폭발 위험에 처하는 압력을 가져옵니다.$(li)$(#800)getCriticalPressure()/$: 기계가 확실히 폭발하는 절대 최대 압력을 가져옵니다."
    },
    {
      "type": "text",
      "title": "열 관련 메서드",
      "text": "다음 메서드들은 $(l:base_concepts/heat)열/$ 개념을 지원하는 $(italic)모든/$ $(pncr) 기계에 공통적입니다:$(li)$(#800)getTemperature(), getTemperature(<side>)/$: 기계의 온도를 가져옵니다. <side>는 선택 사항이며, 측면에 따라 온도가 다른 $(l:machines/vortex_tube)와류 튜브/$에만 유용합니다."
    },
    {
      "type": "spotlight",
      "anchor": "air_cannon",
      "item": "pneumaticcraft:air_cannon",
      "text": "$(li)$(#800)setExternalControl(<true/false>)/$: true일 때, 일반적인 방법(GPS 도구 삽입, 범위 업그레이드 변경 등)으로 대포가 회전하는 것을 방지합니다.$(li)$(#800)setTargetLocation(<x>,<y>,<z>)/$: GPS 도구에 저장된 위치 대신 주어진 목표 위치를 조준합니다."
    },
    {
      "type": "text",
      "title": "공기 대포 (계속)",
      "text": "$(li)$(#800)setRotationAngle(<angle>)/$: 대포의 요(yaw)를 지정된 각도로 회전합니다.$(li)$(#800)setHeightAngle(<angle>)/$: 대포의 피치(pitch)를 지정된 각도로 회전합니다.$(li)$(#800)isDoneRotating()/$: 대포가 회전을 마치면 true를 반환합니다.$(li)$(#800)getMinWorkingPressure()/$: 대포를 발사하는 데 필요한 최소 압력을 반환합니다 (GUI의 노란색에서 초록색 임계값)."
    },
    {
      "type": "text",
      "title": "공기 대포 (계속)",
      "text": "$(li)$(#800)fire()/$: 압력이 충분하고 아이템이 삽입되어 있을 때 대포를 발사합니다. 성공하면 true를 반환합니다."
    },
    {
      "type": "spotlight",
      "anchor": "elevator",
      "item": "pneumaticcraft:elevator_base",
      "title": "엘리베이터",
      "text": "$(li)$(#800)setExternalControl(<true/false>)/$: true일 때, 엘리베이터의 $(#f00)레드스톤 모드/$를 컴퓨터 제어에도 적용되는 '엘리베이터 호출기' 모드로 설정합니다. $(#800)setTargetHeight()/$;를 호출하기 전에 설정할 필요는 없습니다. 해당 메서드는 엘리베이터를 자동으로 외부 제어로 변경합니다."
    },
    {
      "type": "text",
      "title": "엘리베이터 (계속)",
      "text": "$(li)$(#800)getMinWorkingPressure()/$: 엘리베이터를 확장하는 데 필요한 최소 압력을 가져옵니다. 엘리베이터 하강은 무료입니다.$(li)$(#800)setTargetHeight(<height>)/$: 엘리베이터의 목표 높이를 파싱된 높이(미터/블록, 부동 소수점)로 설정합니다.$(li)$(#800)getTargetHeight()/$: 엘리베이터의 목표 높이(미터/블록, 부동 소수점)를 가져옵니다.$(li)$(#800)getCurrentHeight()/$: 엘리베이터의 현재 높이(미터/블록, 부동 소수점)를 가져옵니다."
    },
    {
      "type": "text",
      "title": "엘리베이터 (계속)",
      "text": "$(li)$(#800)getVelocity()/$: 엘리베이터의 현재 속도를 틱당 블록 수로 가져옵니다 (1초는 20틱). 음수 값은 엘리베이터가 하강 중임을 나타냅니다."
    },
    {
      "type": "spotlight",
      "anchor": "universal_sensor",
      "item": "pneumaticcraft:universal_sensor",
      "text": "$(li)$(#800)getSensorNames()/$: 알려진 모든 센서 이름의 테이블을 반환합니다.$(li)$(#800)getSensor()/$: 현재 선택된 센서의 이름을 반환합니다."
    },
    {
      "type": "text",
      "title": "범용 센서 (계속)",
      "text": "$(li)$(#800)setSensor(<sensorName>), setSensor(<index>), setSensor()/$: 현재 선택된 센서를 설정합니다. <sensorName>은 $(#800)getSensorNames()/$에서 반환된 이름 중 하나입니다. <index>는 $(#800)getSensorNames()/$에서 반환된 테이블의 인덱스입니다. 인수 없는 $(#800)setSensor()/$를 사용하면 센서가 선택되지 않습니다(기계가 유휴 상태가 되고 공기를 사용하지 않음). 현재 삽입된 업그레이드로 센서 사용이 가능하면 true를 반환합니다."
    },
    {
      "type": "text",
      "title": "범용 센서 (계속)",
      "text": "$(li)$(#800)setTextField(<text>)/$: 일부 센서는 텍스트 필드를 사용하여 추가 옵션을 지정합니다(예: '범위 내 엔티티' 센서는 $(l:base_concepts/entity_filter)엔티티 필터 문자열/$을 받음). 여기에 원하는 텍스트를 지정할 수 있습니다.$(li)$(#800)getTextField()/$: 현재 $(thing)범용 센서/$에 저장된 텍스트를 반환합니다."
    },
    {
      "type": "text",
      "title": "범용 센서 (계속)",
      "text": "$(li)$(#800)isSensorEventBased()/$: 센서에는 이벤트 기반과 폴링 센서의 두 가지 범주가 있습니다. 이벤트 기반 센서는 무언가 발생하기를 기다립니다(플레이어 공격, 아이템 획득). 폴링 센서는 주기적으로 센서 상태를 확인합니다(범위 내 엔티티, 월드 시간, 비 센서). 현재 선택된 센서가 이벤트 기반이면 이 함수는 true를 반환합니다."
    },
    {
      "type": "text",
      "title": "범용 센서 (계속)",
      "text": "$(li)$(#800)getSensorValue()/$: 현재 센서가 폴링 센서인 경우 출력할 (반전되지 않은) 레드스톤 신호를 반환합니다. 센서를 설정하고 즉시 출력을 가져오는 것은 신뢰할 수 없습니다. 많은 폴링 센서가 성능상의 이유로 자주 폴링하지 않기 때문입니다. 따라서 이 메서드는 강제 업데이트 이벤트를 트리거합니다. 그에 대한 응답으로 출력을 가져오세요. 폴링 센서가 선택되지 않은 경우 예외가 발생합니다."
    },
    {
      "type": "text",
      "title": "범용 센서 (계속)",
      "text": "$(li)$(#800)getMinWorkingPressure()/$: 범용 센서가 작동하는 데 필요한 최소 압력을 반환합니다 (GUI의 노란색에서 초록색 임계값).$(li)$(#800)setGPSToolCoordinate(<slotIndex>,<x>,<y>,<z>)/$: 주어진 슬롯(1부터 시작)에 있는 GPS 도구에 저장된 위치를 제공된 위치로 설정합니다. 위치를 사용하는 센서에 유용합니다."
    },
    {
      "type": "text",
      "title": "범용 센서 (계속)",
      "text": "이벤트 기반 센서(예: 플레이어 우클릭 센서)의 경우, 센서 값을 가져오는 것은 이벤트 기반입니다. $(#800)<arguments> = os.pullEvent(\"universalSensor\")/$.를 수행하여 이벤트를 얻습니다. 일반적으로 인수는 <eventName, redstoneStrength>로 구성됩니다. 플레이어 우클릭 센서는 예외적으로 <eventName, redstoneStrength, interactedX, interactedY, interactedZ>가 반환됩니다. 이를 통해 몇 가지 흥미로운 활용이 가능합니다..."
    }
  ]
}
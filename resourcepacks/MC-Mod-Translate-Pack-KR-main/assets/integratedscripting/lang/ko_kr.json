{
  "_comment": "General",
  "itemGroup.integratedscripting": "Integrated Scripting",
  "general.integratedscripting.description": "Integrated Dynamics에서 복잡한 작업을 처리하기 위한 스크립트를 생성합니다.",

  "_comment": "Achievements",
  "advancement.integratedscripting.mendesite": "멘데사이트 풍년",
  "advancement.integratedscripting.mendesite.desc": "Integrated Scripting의 기본 자원인 멘데사이트 블록을 제작하세요.",
  "advancement.integratedscripting.scripting_disk": "플로피 디스크가 아니야!",
  "advancement.integratedscripting.scripting_disk.desc": "스크립트 데이터를 저장하는 데 사용되는 스크립팅 디스크를 제작하세요.",
  "advancement.integratedscripting.scripting_drive": "드라이브 가동!",
  "advancement.integratedscripting.scripting_drive.desc": "네트워크에 스크립트를 불러올 수 있도록 스크립팅 드라이브를 제작하세요.",
  "advancement.integratedscripting.terminal_open": "스크립트의 발견",
  "advancement.integratedscripting.terminal_open.desc": "스크립팅 터미널 GUI를 여세요.",
  "advancement.integratedscripting.terminal_bind": "스크립트의 부상",
  "advancement.integratedscripting.terminal_bind.desc": "스크립트를 생성하고 변수 카드에 결속하세요.",
  "advancement.integratedscripting.terminal_display": "스크립트의 해방",
  "advancement.integratedscripting.terminal_display.desc": "디스플레이 패널에 스크립트된 값을 표시하세요.",
  "advancement.integratedscripting.filter_chest": "사기급 아이템 목록 필터링",
  "advancement.integratedscripting.filter_chest.desc": "스크립트 기반 함수를 사용하여 상자에서 읽은 아이템 목록을 필터링하세요.",

  "_comment": "Blocks",
  "block.integratedscripting.mendesite": "멘데사이트",

  "_comment": "Gui",
  "gui.integratedscripting.disk": "디스크",
  "gui.integratedscripting.script": "스크립트",
  "gui.integratedscripting.create_file": "파일 생성",
  "gui.integratedscripting.removal_dialog.title": "스크립트 삭제 확인",
  "gui.integratedscripting.removal_dialog.message": "\"%s\"을(를) 삭제하시겠습니까?",
  "gui.integratedscripting.removal_dialog.delete": "삭제",
  "gui.integratedscripting.removal_dialog.keep": "유지",
  "gui.integratedscripting.error.invalid_member": "결속할 스크립트 에디터 내의 유효한 함수 이름이나 변수 이름을 선택하세요.",
  "gui.integratedscripting.error.invalid_member.current": "현재 선택: \"%s\"",

  "_comment": "Value Type Translation",
  "valuetype.integratedscripting.error.translation.unknown_to_graal": "%s 값을 Graal로 변환하는 변환기를 찾을 수 없습니다.",
  "valuetype.integratedscripting.error.translation.unknown_to_graal_nbt": "NBT 변환 중 %s 값을 Graal로 변환하는 변환기를 찾을 수 없습니다.",
  "valuetype.integratedscripting.error.translation.unknown_from_graal": "%s Graal 값에서 변환하는 변환기를 찾을 수 없습니다.",
  "valuetype.integratedscripting.error.translation.list_infinite": "무한 목록은 스크립트 언어로 변환할 수 없습니다.",
  "valuetype.integratedscripting.error.translation.nbt_unknown": "%s 유형의 NBT 멤버를 변환할 수 없습니다.",
  "valuetype.integratedscripting.error.translation.nbt_unmatched": "%s 필드를 NBT로 해석할 수 없습니다.",
  "valuetype.integratedscripting.error.translation.unsupported_translateToNbt": "%s \"%s\"의 NBT로의 불법적인 변환입니다.",
  "valuetype.integratedscripting.error.translation.proxyobject_putMember": "읽기 전용 %s에 키 \"%s\"을(를) 추가하는 것은 불법입니다.",

  "_comment": "Operators",
  "operator.integratedscripting.integratedscript.basename": "통합 스크립트 %s",
  "operator.integratedscripting.integratedscript.graal": "Graal 함수",
  "operator.integratedscripting.error.no_graal_serialization": "통합 스크립트는 직렬화할 수 없습니다.",

  "_comment": "Script Variable",
  "script.integratedscripting.tooltip.disk": "§e§o디스크 ID: §r§o%s",
  "script.integratedscripting.tooltip.path": "§e§o스크립트 경로: §r§o%s",
  "script.integratedscripting.tooltip.member": "§e§o멤버: §r§o%s",
  "script.integratedscripting.error.invalid_network": "유효한 스크립팅 네트워크를 찾을 수 없습니다.",
  "script.integratedscripting.error.disk_not_in_network": "현재 네트워크에서 ID가 %s인 디스크를 찾을 수 없습니다.",
  "script.integratedscripting.error.path_not_in_network": "ID가 %s인 디스크에 \"%s\" 스크립트가 없습니다.",
  "script.integratedscripting.error.member_not_in_network": "ID가 %s인 디스크의 \"%3$s\" 스크립트에 \"%2$s\" 멤버가 없습니다.",
  "script.integratedscripting.error.unsupported_language": "\"%s\" 스크립트의 언어는 지원되지 않습니다.",
  "script.integratedscripting.error.script_read": "디스크 %2$s에서 스크립트 \"%1$s\"을(를) 읽는 중 오류가 발생했습니다: %3$s",
  "script.integratedscripting.error.script_exec": "디스크 %3$s의 스크립트 \"%2$s\"에서 멤버 \"%1$s\"을(를) 실행하는 중 오류가 발생했습니다: %4$s",
  "script.integratedscripting.error.invalid_type": "디스크 %3$s의 스크립트 \"%2$s\"에 있는 멤버 \"%1$s\"을(를) 가진 스크립트는 %4$s 유형의 변수를 노출할 것으로 예상되지만 %5$s이(가) 발견되었습니다.",

  "_comment": "Items",
  "item.integratedscripting.scripting_disk": "스크립팅 디스크",
  "item.integratedscripting.scripting_disk.info": "스크립트를 저장합니다.",
  "item.integratedscripting.scripting_disk.id": "ID: %s",
  "item.integratedscripting.scripting_disk.bytes": "바이트: %s",

  "_comment": "Blocks",
  "block.integratedscripting.scripting_drive": "스크립팅 드라이브",
  "block.integratedscripting.scripting_drive.info": "스크립팅 디스크를 네트워크에 노출합니다.",

  "_comment": "Part types",
  "parttype.integratedscripting.terminal_scripting": "스크립팅 터미널",
  "parttype.integratedscripting.terminal_scripting.info": "네트워크의 스크립팅 드라이브에 있는 스크립트를 관리합니다.",

  "_comment": "------ On the Dynamics of Integration contents ------",

  "info_book.integratedscripting.section.main": "스크립팅",

  "info_book.integratedscripting.introduction": "소개",
  "info_book.integratedscripting.introduction.text1": "&lIntegrated Scripting&r은 &lIntegrated Dynamics&r 네트워크에서 복잡한 작업을 처리하기 위한 스크립트를 생성할 수 있는 &lIntegrated Dynamics&r의 확장 모드입니다. 기본적으로 이 모드는 JavaScript 스크립트 언어 지원을 포함합니다.",
  "info_book.integratedscripting.introduction.text2": "표준적인 시각적 변수 카드 기반 방식 대신 편리한 스크립트 구문을 사용하여 &lIntegrated Dynamics&r 논리 연산을 정의할 수 있습니다. 기존 방식은 복잡한 연산 체인에서 번거로울 수 있습니다.",
  "info_book.integratedscripting.introduction.text3": "예를 들어, &o\"손상 가능하고, 모드 X의 소유이며, 다이아몬드 곡괭이로만 캘 수 있는 블록에 해당하는 아이템\"&r과 같은 복잡한 아이템 목록 필터를 쉽게 정의할 수 있습니다. 또는 &o\"이 목록에서 두 번째로 스택 크기가 큰 아이템 가져오기\"&r와 같은 작업도 가능합니다.",
  "info_book.integratedscripting.introduction.text4": "이 모드를 사용할 때 기본적인 프로그래밍 지식이 권장되지만, 이 책의 뒷부분에 있는 튜토리얼을 통해 배울 수도 있습니다.",

  "info_book.integratedscripting.materials": "재료",
  "info_book.integratedscripting.materials.text1": "스크립팅을 시작하기 전에 &l멘데사이트&r 블록이 필요합니다. 이 블록은 매우 가공하기 쉬우며 스크립트 저장 및 처리를 위한 훌륭한 기반을 형성합니다. &l멘데사이트&r는 &l건조대&r에서 &l멘릴 수지&r와 &l안산암&r을 결합하여 생성됩니다.",

  "info_book.integratedscripting.concepts": "개념",
  "info_book.integratedscripting.concepts.text1": "스크립트를 편집, 저장 및 네트워크에 제공하려면 &l스크립팅 터미널&r, &l스크립팅 디스크&r, &l스크립팅 드라이브&r의 3가지 요소가 필요합니다.",
  "info_book.integratedscripting.concepts.text2": "&l스크립팅 디스크&r는 원시 스크립트 내용을 저장하지만 자체적으로는 아무것도 할 수 없습니다.",
  "info_book.integratedscripting.concepts.text3": "&l스크립팅 드라이브&r는 단일 &l스크립팅 디스크&r를 삽입하여 그 내용을 네트워크에 노출할 수 있게 합니다.",
  "info_book.integratedscripting.concepts.text4": "&l스크립팅 터미널&r은 네트워크의 &l스크립팅 드라이브&r에 의해 노출된 모든 스크립트를 보고, 관리하고, 편집할 수 있게 합니다.",
  "info_book.integratedscripting.concepts.text5": "이러한 각 요소는 이후에 더 자세히 논의될 것입니다.",

  "info_book.integratedscripting.disk": "스크립팅 디스크",
  "info_book.integratedscripting.disk.text1": "&l스크립팅 디스크&r는 스크립트를 저장하는 역할을 하며 &l스크립팅 드라이브&r에 삽입해야 합니다. 몇 가지 &l변수 카드&r와 &l멘데사이트&r를 결합하여 만들 수 있습니다.",
  "info_book.integratedscripting.disk.text2": "&l스크립팅 디스크&r를 &l스크립팅 드라이브&r에 삽입하면 고유한 숫자 식별자를 얻습니다. 이 식별자는 &l스크립팅 터미널&r 내에서 이 디스크의 스크립트를 수정하는 데 사용됩니다. 식별자는 스크립트 요소를 &l변수 카드&r에 연결하는 데에도 사용됩니다.",
  "info_book.integratedscripting.disk.text3": "다른 네트워크라도 &l스크립팅 디스크&r를 다른 &l스크립팅 드라이브&r로 안전하게 옮길 수 있으며 스크립트 데이터는 손실되지 않습니다. 하지만 이 스크립트의 식별자를 참조하는 &l변수 카드&r는 더 이상 같은 네트워크에 있지 않으면 오류를 발생시키기 시작할 것입니다.",
  "info_book.integratedscripting.disk.text4": "&l스크립팅 디스크&r는 저장 용량 제한이 없지만, 관리상의 이유로 여러 디스크에 스크립트를 나누는 것이 좋습니다.",

  "info_book.integratedscripting.drive": "스크립팅 드라이브",
  "info_book.integratedscripting.drive.text1": "각 &l스크립팅 드라이브&r는 &lIntegrated Dynamics&r 네트워크에 연결되는 블록으로, 단일 &l스크립팅 디스크&r를 수용하여 디스크의 스크립트 내용을 네트워크에 노출합니다.",
  "info_book.integratedscripting.drive.text2": "&l변수 저장소&r와 &l주크박스&r, 그리고 몇 개의 &l스크립팅 디스크&r를 결합하여 제작합니다.",

  "info_book.integratedscripting.terminal": "스크립팅 터미널",
  "info_book.integratedscripting.terminal.text1": "&l스크립팅 터미널&r은 네트워크의 &l스크립팅 디스크&r에 저장된 스크립트를 관리하기 위해 &lIntegrated Dynamics&r 네트워크에 연결해야 하는 부품입니다.",
  "info_book.integratedscripting.terminal.text2": "설치된 터미널을 우클릭하면 스크립트를 편집할 수 있는 단순화된 &o통합 개발 환경&r(IDE)이 표시됩니다.",
  "info_book.integratedscripting.terminal.text3": "화면 왼쪽 상단에서 네트워크에 연결된 &l스크립팅 디스크&r의 식별자를 선택할 수 있으며, 그 후 해당 디스크에 저장된 모든 스크립트 파일이 아래의 스크립트 파일 목록에 표시됩니다.",
  "info_book.integratedscripting.terminal.text4": "디스크에 스크립트 파일이 아직 없으면 화면 왼쪽 하단의 \"+\" 버튼을 클릭하여 생성할 수 있습니다.",
  "info_book.integratedscripting.terminal.text5": "화면 왼쪽의 스크립트 파일 목록은 편집할 스크립트를 선택하는 데 사용됩니다. 스크립트를 클릭하면 편집 가능한 내용이 화면 오른쪽에 표시됩니다.",
  "info_book.integratedscripting.terminal.text6": "화면 오른쪽의 텍스트 필드에서는 스크립트 파일의 내용을 편집할 수 있으며, 수정할 때마다 자동으로 저장됩니다.",
  "info_book.integratedscripting.terminal.text7": "에디터는 제한적인 구문 강조 기능을 수행하지만, 현재 구문 오류를 감지할 수는 없습니다. 구문 오류는 &l변수 카드&r를 통해 스크립트를 실행할 때 보고됩니다.",
  "info_book.integratedscripting.terminal.text8": "스크립트 멤버를 &lIntegrated Dynamics&r 논리로 사용하려면 &l변수 카드&r에 결속할 수 있습니다.",
  "info_book.integratedscripting.terminal.text9": "커서로 변수 이름이나 함수 이름과 같은 스크립트 멤버를 텍스트 에디터에서 선택하여 이를 수행할 수 있습니다.",
  "info_book.integratedscripting.terminal.text10": "그 후 화면 오른쪽 슬롯에 &l변수 카드&r를 삽입하여 이 스크립트 멤버에 결속할 수 있습니다.",
  "info_book.integratedscripting.terminal.text11": "이 &l변수 카드&r는 이제 네트워크의 다른 곳에서 사용할 수 있습니다. 예를 들어, 변수 멤버를 &l디스플레이 패널&r에 표시하거나 함수 멤버를 아이템 목록 필터의 연산자로 사용할 수 있습니다.",
  "info_book.integratedscripting.terminal.text12": "다음 장에서는 스크립트 작성 방법에 대해 더 자세히 설명합니다.",

  "info_book.integratedscripting.writing": "스크립트 작성",

  "info_book.integratedscripting.writing.js": "JavaScript",
  "info_book.integratedscripting.writing.js.text1": "이 모드에서는 JavaScript 구문으로 스크립트를 작성할 수 있습니다. ECMAScript(ECMA-262)에서 허용하는 모든 기능을 사용할 수 있습니다.",
  "info_book.integratedscripting.writing.js.text2": "&orequire&r 및 &ofs&r와 같은 Node.js 관련 기능은 사용할 수 없습니다. Node.js 애플리케이션 개발에 익숙하다면 Webpack과 같은 외부 도구를 사용하여 호환되게 만들 수 있습니다.",

  "info_book.integratedscripting.writing.variables": "상수 및 변수",
  "info_book.integratedscripting.writing.variables.text1": "익숙한 모든 Integrated Dynamics 값 유형(&6정수&0, &9부울&0, &8아이템&0 등)은 JavaScript에서 사용할 수 있으며 그 반대도 가능합니다.",
  "info_book.integratedscripting.writing.variables.text2": "JavaScript에서 값을 생성하여 정적 &l변수 카드&r 값으로 만드는 가장 간단한 방법은 &olet&r 또는 &oconst&r를 사용하여 JavaScript에서 변수 멤버를 정의하는 것입니다.",
  "info_book.integratedscripting.writing.variables.text3": "&olet&r은 카운터와 같이 스크립트에서 나중에 재할당할 수 있는 변수를 정의합니다. &oconst&r는 재할당할 수 없는 변수를 정의합니다.",
  "info_book.integratedscripting.writing.variables.text4": "이 값을 &l변수 카드&r에서 사용하려면 스크립팅 터미널 텍스트 에디터에서 변수 멤버 이름을 선택한 다음 오른쪽 슬롯에 빈 &l변수 카드&r를 삽입해야 합니다. 이제 &l디스플레이 패널&r에서 값을 시각화하는 등 익숙한 방식으로 이 &l변수 카드&r를 사용할 수 있습니다.",
  "info_book.integratedscripting.writing.variables.text5": "JavaScript를 통한 변수 생성은 주로 특정 값을 가진 긴 &4문자열&0과 같이 &l논리 프로그래머&r를 사용하여 만들기 어려운 복잡한 값을 생성해야 할 때 유용합니다. 아래에서 이러한 값을 만드는 몇 가지 예를 찾을 수 있습니다.",

  "info_book.integratedscripting.writing.functions": "함수",
  "info_book.integratedscripting.writing.functions.text1": "&2연산자&0는 Integrated Dynamics 논리의 일급 시민이므로 JavaScript 함수로 생성할 수도 있습니다.",
  "info_book.integratedscripting.writing.functions.text2": "&ofunction&r 키워드를 사용하거나 사용자 지정 람다를 생성하는 등 JavaScript 함수를 생성하는 모든 방법을 사용하여 &2연산자&0를 생성할 수 있습니다.",
  "info_book.integratedscripting.writing.functions.text3": "함수는 여러 인수를 허용하며, Integrated Dynamics 논리를 통해 실행될 때 JavaScript 값으로 변환된 일반 Integrated Dynamics 값을 받습니다.",
  "info_book.integratedscripting.writing.functions.text4": "JavaScript 함수를 &2연산자&0로 &l변수 카드&r에 결속하는 것은 상수 및 변수와 마찬가지로 스크립팅 터미널 텍스트 에디터에서 함수 멤버 이름을 선택하고 &l변수 카드&r에 결속하여 수행됩니다. 이 값은 이제 &2연산자&0가 허용되는 모든 곳에서 사용할 수 있습니다.",
  "info_book.integratedscripting.writing.functions.text5": "예를 들어, 단일 &8아이템&0 인수를 받아 &9부울&0을 반환하는 함수를 생성하여 상자에서 읽은 아이템 목록을 필터링하기 위한 필터 &2연산자&0로 사용할 수 있습니다.",
  "info_book.integratedscripting.writing.functions.text6": "아래에서 생성할 수 있는 다양한 유형의 함수의 예를 찾을 수 있습니다.",

  "info_book.integratedscripting.writing.globals": "전역 함수",
  "info_book.integratedscripting.writing.globals.text1": "JavaScript 코드를 작성할 때 전역 &oidContext&r 변수를 사용하여 &oops&r 필드를 통해 모든 Integrated Dynamics 연산자에 함수로 액세스할 수 있습니다. 이를 통해 새 연산자를 만들 때 내장 연산자를 사용할 수 있습니다.",
  "info_book.integratedscripting.writing.globals.text2": "예를 들어, 아래와 같이 아이템이 스택 가능하고 스택 크기가 16 이상인지 확인하는 &8아이템&0 필터를 작성할 수 있습니다.",
  "info_book.integratedscripting.writing.globals.text3": "실행하려는 연산자의 이름을 알기 위해 &l논리 프로그래머&r의 연산자 툴팁이나 이 책의 논리 프로그래밍 섹션에 있는 연산자 목록에서 전역 이름을 확인할 수 있습니다.",
  "info_book.integratedscripting.writing.globals.text4": "&oidContext&r를 통해 연산자를 호출하는 것은 꽤 장황할 수 있으므로 두 번째 예제와 같이 사용자 지정 상수 변수에 연산자를 저장하도록 선택할 수 있습니다. 또는 다음 섹션에서 설명하는 &o객체 메서드&r를 사용할 수 있습니다.",

  "info_book.integratedscripting.writing.methods": "객체 메서드",
  "info_book.integratedscripting.writing.methods.text1": "전역 함수의 장황함을 피하기 위해 &o객체 메서드&r를 사용하여 코드를 더 간결하게 작성할 수 있습니다.",
  "info_book.integratedscripting.writing.methods.text2": "&8블록&0, &8아이템&0, &8액체&0 등의 객체 값 유형은 JavaScript에서 사용할 때 &l메서드&r가 연결되어 있습니다.",
  "info_book.integratedscripting.writing.methods.text3": "객체 메서드는 일반 함수일 뿐이지만 첫 번째 인수가 객체 값에 연결됩니다.",
  "info_book.integratedscripting.writing.methods.text4": "예를 들어, 전역 함수 &oitemstackStackable&r은 단일 &8아이템&0 인수를 받아 &9부울&0을 출력합니다. 이 함수는 인수를 받지 않는 &ostackable&r이라는 이름을 통해 &8아이템&0 값의 메서드로 사용할 수 있습니다.",
  "info_book.integratedscripting.writing.methods.text5": "2개 이상의 인수를 허용하는 전역 함수는 모든 인수가 하나씩 이동된 상태로 객체 값의 메서드로 사용할 수 있습니다. 예를 들어, 전역 함수 &oitemstackStrength&r는 &8아이템&0과 &8블록&0 인수를 허용하지만, 단일 &8블록&0 인수를 가진 &8아이템&0의 메서드로도 사용할 수 있습니다.",

  "info_book.integratedscripting.advanced": "고급",

  "info_book.integratedscripting.advanced.transient_storage": "일시적 저장소",
  "info_book.integratedscripting.advanced.transient_storage.text1": "Integrated Dynamics는 함수형 프로그래밍 원칙을 기반으로 하므로 &l지연기&r와 같은 외부 접근 방식을 제외하고는 상태 추적이 거의 존재하지 않습니다.",
  "info_book.integratedscripting.advanced.transient_storage.text2": "JavaScript 언어는 함수형 프로그래밍과 명령형 프로그래밍의 혼합을 제공하므로 상태 추적이 부분적으로 가능합니다.",
  "info_book.integratedscripting.advanced.transient_storage.text3": "구체적으로 함수 외부에서 가변 변수를 선언하면(예: &olet&r 사용) 함수 호출을 통해 값을 수정할 수 있습니다.",
  "info_book.integratedscripting.advanced.transient_storage.text4": "이 방법으로 함수 호출 횟수를 세거나 특정 값의 누적 평균을 계산하는 등의 상태를 추적할 수 있습니다.",
  "info_book.integratedscripting.advanced.transient_storage.text5": "이러한 변수의 중요한 점은 상태가 일시적일 뿐이라는 것입니다. 구체적으로 네트워크의 변수 카드가 다시 삽입되거나 서버가 다시 시작될 때마다 값이 초기화될 수 있음을 의미합니다.",
  "info_book.integratedscripting.advanced.transient_storage.text6": "따라서 이러한 값이 항상 존재한다고 가정할 수 없습니다. 영구 데이터 저장이 필요한 경우 &l지연기&r를 사용하는 것이 좋습니다.",

  "info_book.integratedscripting.advanced.external_editing": "외부 편집",
  "info_book.integratedscripting.advanced.external_editing.text1": "싱글플레이어 또는 멀티플레이어 게임이 실행 중인 파일 시스템에 액세스할 수 있는 경우 외부 에디터를 통해 스크립트 파일에 액세스할 수 있습니다. 이를 통해 좋아하는 IDE(Vi는 되지만 Emacs는 절대 안 됨)를 사용하여 스크립트를 만들 수 있습니다.",
  "info_book.integratedscripting.advanced.external_editing.text2": "스크립트 파일은 &oworld/integratedscripting/&r 디렉토리를 통해 액세스할 수 있습니다(싱글플레이어 월드의 경우 &osaves/&r 참조). 여기에서 ID별로 모든 &l스크립팅 디스크&r 디렉토리를 찾을 수 있습니다. 각 &l스크립팅 디스크&r 디렉토리 내에서 해당 디스크에 저장된 모든 스크립트 파일을 찾을 수 있습니다.",
  "info_book.integratedscripting.advanced.external_editing.text3": "게임이 실행 중이더라도 외부 에디터를 통해 이 스크립트 파일을 안전하게 수정할 수 있습니다. 파일을 외부에서 저장하면 게임 내에서 자동으로 업데이트되며 종속 변수도 업데이트됩니다.",
  "info_book.integratedscripting.advanced.external_editing.text4": "외부 에디터가 이를 지원하는 경우(최신 IDE는 지원함) &l스크립팅 터미널&r을 통해 스크립트 파일을 수정하면 외부 에디터에서도 파일이 업데이트됩니다.",

  "info_book.integratedscripting.advanced.logging": "로깅",
  "info_book.integratedscripting.advanced.logging.text1": "복잡한 스크립트의 경우 외부 로그 파일에 임시로 기록하여 디버깅해야 할 수 있습니다.",
  "info_book.integratedscripting.advanced.logging.text2": "JavaScript에서는 &oconsole.log()&r 및 &oconsole.error()&r와 같은 함수를 호출하여 각각 &o표준 출력&r 및 &o표준 오류&r 출력 스트림에 메시지를 쓸 수 있습니다.",
  "info_book.integratedscripting.advanced.logging.text3": "이러한 함수를 호출하면 로그 메시지가 각각 스크립트에 종속된 &o.stdout&r 및 &o.stderr&r 파일에 기록됩니다.",
  "info_book.integratedscripting.advanced.logging.text4": "예를 들어 스크립트가 &omyfile.js&r에 있는 경우 로그 메시지는 &omyfile.js.stdout&r에 기록됩니다.",
  "info_book.integratedscripting.advanced.logging.text5": "이러한 &o.stdout&r 및 &o.stderr&r 파일은 &l스크립팅 터미널&r이나 외부 편집을 통해 액세스할 수 있습니다.",
  "info_book.integratedscripting.advanced.logging.text6": "로그 파일이 너무 커지는 것을 방지하기 위해 크기가 제한됩니다. 기본적으로 2096줄로 제한됩니다. 더 많은 줄이 필요한 경우 서버 관리자에게 문의하세요.",

  "info_book.integratedscripting.advanced.typescript": "TypeScript",
  "info_book.integratedscripting.advanced.typescript.text1": "TypeScript 언어는 타이핑 지원을 추가하는 잘 알려진 JavaScript의 상위 집합입니다. 이를 통해 개발자는 변수와 함수의 유형을 정의하여 유형 안전(type-safe) JavaScript를 작성할 수 있습니다.",
  "info_book.integratedscripting.advanced.typescript.text2": "Integrated Scripting은 순수 JavaScript만 지원하지만, 사용 가능한 모든 전역 함수, 값 유형 및 해당 메서드에 대한 TypeScript &o타이핑 파일&r을 사용할 수 있습니다.",
  "info_book.integratedscripting.advanced.typescript.text3": "외부 IDE를 통해 스크립트를 편집할 때 이 타이핑 파일을 로드하여 유형 안전 스크립트를 만들 수 있습니다. 이는 TypeScript를 알고 사용법을 아는 경우에만 권장됩니다.",
  "info_book.integratedscripting.advanced.typescript.text4": "타이핑 파일은 &oworld/integratedscripting/integratedscripting.d.ts&r에서 사용할 수 있습니다(싱글플레이어 월드의 경우 &osaves/&r 참조). 이 파일은 월드가 다시 시작될 때마다 자동으로 다시 생성되므로 이 파일을 수동으로 조정해서는 안 됩니다.",

  "info_book.integratedscripting.section.tutorials": "스크립팅 튜토리얼",

  "info_book.integratedscripting.tutorials.introduction": "소개",
  "info_book.integratedscripting.tutorials.introduction.text1": "이 섹션에는 &lIntegrated Dynamics&r의 확장 모드인 &lIntegrated Scripting&r을 사용하여 복잡한 작업을 처리하는 스크립트를 만드는 방법을 배우는 데 도움이 되는 몇 가지 튜토리얼이 포함되어 있습니다.",

  "info_book.integratedscripting.tutorials.basics": "스크립팅의 기초",
  "info_book.integratedscripting.tutorials.basics.text1": "&l멘데사이트&r 블록은 스크립팅 관련 아이템의 기초 제작 재료입니다. &l건조대&r를 사용하여 몇 개 만들어 봅시다!",
  "info_book.integratedscripting.tutorials.basics.text2": "다음으로 이 &l멘데사이트&r 블록을 사용하여 &l스크립팅 디스크&r와 &l스크립팅 드라이브&r를 만듭니다. &l스크립팅 디스크&r는 스크립팅 데이터를 저장할 수 있으며 &l스크립팅 드라이브&r는 이러한 디스크를 네트워크에 삽입할 수 있게 해줍니다.",
  "info_book.integratedscripting.tutorials.basics.text3": "마지막으로 &l스크립팅 드라이브&r를 배치하고 그 안에 &l스크립팅 디스크&r를 저장해 봅시다. 이렇게 하면 다음 튜토리얼에서 스크립트를 저장할 수 있습니다.",

  "info_book.integratedscripting.tutorials.terminal": "스크립팅 터미널 사용하기",
  "info_book.integratedscripting.tutorials.terminal.text1": "이전 단계에서 &l스크립팅 디스크&r와 &l스크립팅 드라이브&r를 만들고 배치했습니다. 이 튜토리얼에서는 실제로 스크립트를 &o작성&r하고 &l변수 카드&r에 결속하는 방법을 알아봅니다.",
  "info_book.integratedscripting.tutorials.terminal.text2": "먼저 &l스크립팅 터미널&r을 제작하고 &l스크립팅 드라이브&r에 연결된 케이블에 배치한 다음 &l스크립팅 터미널&r을 우클릭하여 엽니다.",
  "info_book.integratedscripting.tutorials.terminal.text3": "네트워크에서 액세스할 수 있는 다양한 &l스크립팅 디스크&r에 저장된 모든 스크립트 파일에 액세스할 수 있는 에디터가 표시됩니다. 화면 왼쪽 상단의 화살표를 클릭하여 다른 &l스크립팅 디스크&r로 전환할 수 있습니다.",
  "info_book.integratedscripting.tutorials.terminal.text4": "이 단계에서는 아직 네트워크에 스크립트 파일이 없으므로 화면 왼쪽 하단의 \"+\" 버튼을 클릭하여 새 파일을 만듭니다. 이제 새 파일을 클릭하여 열고 화면 오른쪽의 텍스트 필드를 클릭하여 파일을 편집하고 &oJavaScript&r 코드를 작성합니다.",
  "info_book.integratedscripting.tutorials.terminal.text5": "지금은 간단하게 상수 값을 만들어 보겠습니다. &oconst myVar = 123;&r과 같이 작성해 보세요.",
  "info_book.integratedscripting.tutorials.terminal.text6": "마지막 단계로 화면 오른쪽 슬롯에 빈 &l변수 카드&r를 삽입하고 커서로 변수를 더블 클릭하여 선택함으로써 이 상수를 &l변수 카드&r에 결속해 봅시다. &l변수 카드&r가 이제 상수 값에 결속되었습니다. 이제 이 &l변수 카드&r를 네트워크의 어디에서나 사용할 수 있습니다. &l디스플레이 패널&r에 표시해 보세요!",

  "info_book.integratedscripting.tutorials.functions": "스크립팅 함수",
  "info_book.integratedscripting.tutorials.functions.text1": "JavaScript를 통해 상수 값을 만드는 것도 재미있을 수 있지만, 이러한 스크립트의 진정한 힘은 &o함수&r를 만들 때 드러납니다.",
  "info_book.integratedscripting.tutorials.functions.text2": "JavaScript를 통해 생성된 함수는 &l변수 카드&r에 &2연산자&0로 결속될 수 있으며, 이는 평소와 같이 Integrated Dynamics 논리에서 사용할 수 있습니다. 예를 들어, Integrated Tunnels 수출기 필터를 정의하거나 목록에 있는 아이템의 중간 스택 크기와 같은 복잡한 값을 계산하는 데 사용할 수 있습니다.",
  "info_book.integratedscripting.tutorials.functions.text3": "이 튜토리얼에서는 단일 &8아이템&0 인수를 받아 출력으로 &9부울&0을 반환하는 함수를 만듭니다. 이 함수는 아이템 목록을 필터링할 때 사용할 수 있는 필터 연산자 역할을 합니다.",
  "info_book.integratedscripting.tutorials.functions.text4": "구체적으로 &l인벤토리 리더&r를 사용하여 아이템 목록을 읽고 새로 만든 함수를 사용하여 &l필터링(Filter)&r합니다. 에디터에서 함수를 선택하고 빈 &l변수 카드&r를 삽입하여 &2연산자&0로 저장함으로써 함수를 &l변수 카드&r에 결속할 수 있습니다.",
  "info_book.integratedscripting.tutorials.functions.text5": "이 튜토리얼에서는 필터 함수의 어떤 구현이든 자유롭게 사용할 수 있습니다. 이후에 자유롭게 복사할 수 있는 유효한 예제 스크립트를 찾을 수 있습니다.",
  "info_book.integratedscripting.tutorials.functions.text6": "튜토리얼을 완료하려면 필터링된 목록의 결과를 &l디스플레이 패널&r에 표시하세요.",
  "info_book.integratedscripting.tutorials.functions.text7": "이 예제 스크립트에서는 &oisStackable()&r 및 &ostacksize()&r와 같은 아이템의 내장 메서드를 호출할 수 있음을 알 수 있습니다. 사용할 수 있는 메서드에 대한 자세한 내용은 나중에 전체 설명서에서 확인할 수 있습니다."
}